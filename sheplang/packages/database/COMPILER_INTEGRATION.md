# ğŸ”Œ Compiler Integration Guide

This guide shows how to update your ShepLang compiler to use the centralized `@goldensheepai/sheplang-database` package instead of creating new Prisma Client instances.

---

## ğŸ¯ Why Use Centralized Client?

**Current Issue:** Your compiler generates code that creates new `PrismaClient` instances:
```typescript
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient(); // âŒ Creates new instance each time
```

**Problems:**
- âŒ Multiple connections to database (connection pool exhaustion)
- âŒ Slower performance (each instance initializes separately)
- âŒ More memory usage
- âŒ Connection limit errors in serverless environments

**Solution:** Use the centralized singleton client:
```typescript
import { prisma } from '@goldensheepai/sheplang-database'; // âœ… Reuses singleton
```

**Benefits:**
- âœ… Single connection pool (efficient)
- âœ… Faster startup (client already initialized)
- âœ… Less memory usage
- âœ… Production-ready pattern

---

## ğŸ“ Step-by-Step Integration

### Step 1: Add Database Package as Dependency

**File:** `sheplang/packages/compiler/package.json`

Add to `dependencies`:
```json
{
  "dependencies": {
    "typescript": "^5.6.3",
    "@goldensheepai/sheplang-database": "workspace:*"
  }
}
```

Then run from the compiler directory:
```bash
pnpm install
```

### Step 2: Update API Templates

**File:** `sheplang/packages/compiler/src/api-templates.ts`

**Find this section (around line 14-19):**
```typescript
const content = `// Auto-generated by ShepLang
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';

const router = Router();
const prisma = new PrismaClient();
```

**Replace with:**
```typescript
const content = `// Auto-generated by ShepLang
import { Router } from 'express';
import { prisma } from '@goldensheepai/sheplang-database';

const router = Router();
```

**That's it!** The rest of the template works exactly the same.

### Step 3: Update Package.json Template (Optional)

**File:** `sheplang/packages/compiler/src/api-templates.ts`

**Find the `templateApiPackageJson` function (around line 143):**
```typescript
dependencies: {
  '@prisma/client': '^5.0.0',
  express: '^4.18.0',
  cors: '^2.8.5'
}
```

**Update to:**
```typescript
dependencies: {
  '@goldensheepai/sheplang-database': 'workspace:*',
  express: '^4.18.0',
  cors: '^2.8.5'
}
```

And update the scripts section to remove redundant Prisma commands:
```typescript
scripts: {
  dev: 'tsx watch api/server.ts',
  build: 'tsc',
  start: 'node dist/api/server.js'
  // Remove these (database package handles them):
  // 'db:generate': 'prisma generate',
  // 'db:push': 'prisma db push',
  // 'db:migrate': 'prisma migrate dev'
}
```

---

## ğŸ§ª Testing the Changes

### 1. Rebuild the Compiler

```bash
cd sheplang/packages/compiler
pnpm run build
```

### 2. Generate a Test App

Create a test ShepLang file:

```sheplang
app TestApp

data User:
  fields:
    name: text
    email: text

view UserList:
  list User

action CreateUser(name, email):
  add User with name, email
  show UserList
```

### 3. Compile It

```bash
sheplang compile test-app.shep --out ./test-output
```

### 4. Verify Generated Code

Check `test-output/api/routes/users.ts`:

**Should contain:**
```typescript
import { prisma } from '@goldensheepai/sheplang-database'; // âœ… Correct
```

**Should NOT contain:**
```typescript
import { PrismaClient } from '@prisma/client'; // âŒ Old pattern
const prisma = new PrismaClient();
```

### 5. Run the Generated App

```bash
cd test-output
pnpm install
pnpm run dev
```

Verify it connects to the database without errors.

---

## ğŸ“Š Before vs After

### Before (Current)

**Generated Code:**
```typescript
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';

const router = Router();
const prisma = new PrismaClient(); // âŒ New instance every time

router.get('/users', async (req, res) => {
  const items = await prisma.user.findMany();
  res.json(items);
});
```

**Problems:**
- Each API route file creates its own Prisma Client
- In a typical app with 5 entities, you'd have 5 separate clients
- Connection pool exhaustion in production

### After (Updated)

**Generated Code:**
```typescript
import { Router } from 'express';
import { prisma } from '@goldensheepai/sheplang-database';

const router = Router(); // âœ… Reuses singleton

router.get('/users', async (req, res) => {
  const items = await prisma.user.findMany();
  res.json(items);
});
```

**Benefits:**
- All routes share the same Prisma Client
- Optimal connection pooling
- Production-ready architecture

---

## ğŸ”„ Migration for Existing Projects

If you've already generated apps using the old pattern:

### Option 1: Regenerate

Simply recompile your `.shep` files with the updated compiler.

### Option 2: Manual Update

For each generated API route file:

**Find:**
```typescript
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
```

**Replace with:**
```typescript
import { prisma } from '@goldensheepai/sheplang-database';
```

Then update `package.json` dependencies:

**Remove:**
```json
"@prisma/client": "^5.0.0",
"prisma": "^5.0.0"
```

**Add:**
```json
"@goldensheepai/sheplang-database": "workspace:*"
```

---

## ğŸ¯ Advanced: Custom Client Configuration

If you need custom Prisma Client configuration, update the database package instead of the compiler:

**File:** `sheplang/packages/database/src/client.ts`

```typescript
export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' 
    ? ['query', 'error', 'warn'] 
    : ['error'],
  
  // Add custom options:
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  
  // Connection pool settings:
  // (Neon handles this automatically, but you can override)
});
```

This way, all generated apps automatically inherit the configuration.

---

## âœ… Checklist

- [ ] Added database package as dependency in `compiler/package.json`
- [ ] Updated `api-templates.ts` import statements
- [ ] Updated `templateApiPackageJson` function
- [ ] Rebuilt the compiler (`pnpm run build`)
- [ ] Generated a test app
- [ ] Verified generated code uses centralized client
- [ ] Tested the generated app connects to database
- [ ] Updated existing projects (if any)

---

## ğŸš€ Next Steps

1. **Test with All Examples** - Generate all example apps and verify they work
2. **Update Documentation** - Update ShepLang docs to reference the database package
3. **CI/CD Integration** - Ensure database package is built before compiler in pipelines
4. **Version Alignment** - Keep database package version in sync with compiler

---

## ğŸ› Troubleshooting

### Error: "Cannot find module '@goldensheepai/sheplang-database'"

**Solution:**
- Ensure database package is built: `cd packages/database && pnpm run build`
- Ensure workspace is installed: `cd sheplang && pnpm install`

### Generated code still uses old pattern

**Solution:**
- Verify compiler templates were updated correctly
- Rebuild compiler: `cd packages/compiler && pnpm run build`
- Clear any cached compiled output

### Database connection issues in generated app

**Solution:**
- Ensure `.env` file exists in generated app root
- Copy `DATABASE_URL` from `packages/database/.env`
- Or better: use a shared `.env` at workspace root

---

**Status:** ğŸ‰ **READY TO INTEGRATE!**

Follow the steps above to upgrade your compiler to use the centralized database client.
