import type { AppModel } from '@goldensheepai/sheplang-language';
import { extractEndpoints, groupEndpointsByBasePath } from './endpoint-extractor.js';
import { generateRouterFile } from './endpoint-generator.js';

/**
 * Generate Express API routes for CRUD operations
 * Phase 3-02: Now includes endpoints from CallStmt/LoadStmt
 */
export function templateApiRoutes(app: AppModel): { path: string; content: string }[] {
  const files: { path: string; content: string }[] = [];
  
  // Phase 3-02: Extract custom endpoints from actions
  const customEndpoints = extractEndpoints(app);
  const groupedEndpoints = groupEndpointsByBasePath(customEndpoints);
  
  // Track which base paths have custom endpoints to avoid duplicates
  const customBasePaths = new Set(groupedEndpoints.keys());
  
  // Phase 3-02: Generate router files for custom endpoints
  for (const [basePath, endpoints] of groupedEndpoints) {
    const routerFile = generateRouterFile(basePath, endpoints, app);
    files.push(routerFile);
  }
  
  // Generate default CRUD routes only for entities without custom endpoints
  app.datas.forEach((d) => {
    const entityName = d.name;
    const routeName = entityName.toLowerCase() + 's';
    const basePath = `/${routeName}`;
    
    // Skip if custom endpoints already exist for this path
    if (customBasePaths.has(basePath)) {
      return;
    }
    
    const content = `// Auto-generated by ShepLang
import { Router } from 'express';
import { PrismaClient } from '@prisma/client';

const router = Router();
const prisma = new PrismaClient();

// GET all ${entityName}s
router.get('/', async (req, res) => {
  try {
    const items = await prisma.${entityName.toLowerCase()}.findMany({
      orderBy: { createdAt: 'desc' }
    });
    res.json(items);
  } catch (error) {
    console.error('Error fetching ${routeName}:', error);
    res.status(500).json({ error: 'Failed to fetch ${routeName}' });
  }
});

// GET single ${entityName} by ID
router.get('/:id', async (req, res) => {
  try {
    const item = await prisma.${entityName.toLowerCase()}.findUnique({
      where: { id: req.params.id }
    });
    if (!item) {
      return res.status(404).json({ error: '${entityName} not found' });
    }
    res.json(item);
  } catch (error) {
    console.error('Error fetching ${entityName}:', error);
    res.status(500).json({ error: 'Failed to fetch ${entityName}' });
  }
});

// POST create new ${entityName}
router.post('/', async (req, res) => {
  try {
    const item = await prisma.${entityName.toLowerCase()}.create({
      data: req.body
    });
    res.status(201).json(item);
  } catch (error) {
    console.error('Error creating ${entityName}:', error);
    res.status(500).json({ error: 'Failed to create ${entityName}' });
  }
});

// PUT update ${entityName}
router.put('/:id', async (req, res) => {
  try {
    const item = await prisma.${entityName.toLowerCase()}.update({
      where: { id: req.params.id },
      data: req.body
    });
    res.json(item);
  } catch (error) {
    console.error('Error updating ${entityName}:', error);
    res.status(500).json({ error: 'Failed to update ${entityName}' });
  }
});

// DELETE ${entityName}
router.delete('/:id', async (req, res) => {
  try {
    await prisma.${entityName.toLowerCase()}.delete({
      where: { id: req.params.id }
    });
    res.status(204).send();
  } catch (error) {
    console.error('Error deleting ${entityName}:', error);
    res.status(500).json({ error: 'Failed to delete ${entityName}' });
  }
});

export default router;
`;
    
    files.push({ path: `api/routes/${routeName}.ts`, content });
  });
  
  // Generate main API server file - exclude data models with custom endpoints
  const routeImports = app.datas
    .filter(d => {
      const routeName = d.name.toLowerCase() + 's';
      const basePath = `/${routeName}`;
      return !customBasePaths.has(basePath);
    })
    .map((d) => {
      const routeName = d.name.toLowerCase() + 's';
      return `import ${routeName}Routes from './routes/${routeName}';`;
    }).join('\n');
  
  // Phase 3-02: Add custom endpoint route imports
  const customRouteImports = Array.from(groupedEndpoints.keys()).map(basePath => {
    const routeName = basePath.replace(/^\//, '').replace(/\//g, '-');
    return `import ${routeName.replace(/-/g, '')}Routes from './routes/${routeName}';`;
  }).join('\n');
  
  const allImports = [routeImports, customRouteImports].filter(Boolean).join('\n');
  
  const routeUsage = app.datas
    .filter(d => {
      const routeName = d.name.toLowerCase() + 's';
      const basePath = `/${routeName}`;
      return !customBasePaths.has(basePath);
    })
    .map((d) => {
      const routeName = d.name.toLowerCase() + 's';
      return `app.use('/api/${routeName}', ${routeName}Routes);`;
    }).join('\n  ');
  
  // Phase 3-02: Add custom endpoint route usage
  const customRouteUsage = Array.from(groupedEndpoints.keys()).map(basePath => {
    const routeName = basePath.replace(/^\//, '').replace(/\//g, '-');
    return `app.use('/api${basePath}', ${routeName.replace(/-/g, '')}Routes);`;
  }).join('\n  ');
  
  const allRouteUsage = [routeUsage, customRouteUsage].filter(Boolean).join('\n  ');
  
  const serverContent = `// Auto-generated by ShepLang
import express from 'express';
import cors from 'cors';
${allImports}

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
  ${allRouteUsage}

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', app: '${app.name}' });
});

// Start server
app.listen(PORT, () => {
  console.log(\`${app.name} API server running on port \${PORT}\`);
});

export default app;
`;
  
  files.push({ path: `api/server.ts`, content: serverContent });
  
  return files;
}

/**
 * Generate package.json for API server
 */
export function templateApiPackageJson(app: AppModel): { path: string; content: string } {
  const content = {
    name: `${app.name.toLowerCase()}-api`,
    version: '1.0.0',
    description: `API server for ${app.name}`,
    main: 'dist/api/server.js',
    scripts: {
      dev: 'prisma generate && tsx watch api/server.ts',
      build: 'prisma generate && tsc',
      start: 'node dist/api/server.js',
      postinstall: 'prisma generate'
    },
    dependencies: {
      '@prisma/client': '^6.0.1',
      express: '^4.18.0',
      cors: '^2.8.5'
    },
    devDependencies: {
      '@types/express': '^4.17.0',
      '@types/cors': '^2.8.0',
      '@types/node': '^20.0.0',
      prisma: '^6.0.1',
      tsx: '^4.0.0',
      typescript: '^5.0.0'
    }
  };
  
  return {
    path: 'package.json',
    content: JSON.stringify(content, null, 2)
  };
}
