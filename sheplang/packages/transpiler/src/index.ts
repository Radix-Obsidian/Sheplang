import fs from 'node:fs/promises';
import path from 'node:path';
import { generateTypeDefinitions, generateActionTypes, generateActions, generateViews } from './generators';
import type { AppModel, TranspilerOptions, TranspileResult } from './types';

// Re-export all types
export * from './types';

/**
 * Transpile a ShepLang app model to TypeScript
 * 
 * @param app The parsed app model
 * @param options Transpiler configuration options
 * @returns Result object with paths to generated files
 */
export async function transpileToTS(
  app: AppModel, 
  options: TranspilerOptions = {}
): Promise<TranspileResult> {
  const outDirRoot = options.outDir || '.shep/out';
  const outDir = path.join(outDirRoot, app.name);
  await fs.mkdir(outDir, { recursive: true });
  
  // Generate all sections of TypeScript code
  const typeDefsTs = generateTypeDefinitions(app);
  const actionTypesTs = generateActionTypes();
  const viewsTs = generateViews(app);
  const actionsTs = generateActions(app);

  // Combine everything into the entry file
  const entry = `/* Auto-generated by @sheplang/transpiler */

// Type definitions
${typeDefsTs}

// Navigation and action types
${actionTypesTs}

// View definitions and utilities 
${viewsTs}

// Action implementations
${actionsTs}

// Export a version marker for compatibility checking
export const __version = '1.0.0';
`;

  // Write the entry file
  const entryPath = path.join(outDir, 'entry.ts');
  await fs.writeFile(entryPath, entry, 'utf8');

  // Generate a snapshot for future comparison if requested
  let snapshotPath: string | undefined;
  if (options.generateSnapshots) {
    const snapshotDir = path.join(outDir, 'snapshots');
    await fs.mkdir(snapshotDir, { recursive: true });
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    snapshotPath = path.join(snapshotDir, `entry-${timestamp}.ts`);
    await fs.writeFile(snapshotPath, entry, 'utf8');
  }

  return { entryPath, outDir, snapshotPath };
}
