/**
 * ShepThon Route Generator for Slice 5
 * 
 * Deterministic ShepThon generation from parsed API routes.
 * No AI or vscode dependencies - can be used in tests.
 */

import { 
  APIRoute, 
  ShepThonEndpoint,
  PrismaOperation,
  HTTPMethod 
} from '../types/APIRoute';
import { Entity } from '../types/Entity';

/**
 * Extended ShepThon file with details
 */
export interface ShepThonFileExtended {
  filename: string;
  content: string;
  models: string[];
  endpoints: ShepThonEndpoint[];
}

/**
 * Generate ShepThon file from parsed API routes (deterministic, no AI)
 */
export function generateShepThonFromRoutes(
  routes: APIRoute[],
  entities: Entity[] = []
): ShepThonFileExtended {
  const models = new Set<string>();
  const endpoints: ShepThonEndpoint[] = [];
  const lines: string[] = [];

  // Header comment
  lines.push('# Auto-generated ShepThon backend from Next.js API routes');
  lines.push('# Generated by ShepLang AST Importer (Slice 5)');
  lines.push('');

  // Generate models from entities or infer from routes
  const modelDefs = generateModelDefinitions(routes, entities);
  if (modelDefs.length > 0) {
    lines.push('# Data Models');
    lines.push(...modelDefs);
    lines.push('');
  }

  // Generate endpoints from routes
  lines.push('# API Endpoints');
  for (const route of routes) {
    const endpoint = routeToEndpoint(route);
    if (endpoint) {
      endpoints.push(endpoint);
      models.add(endpoint.model);
      lines.push(generateEndpointLine(endpoint, route));
    }
  }

  return {
    filename: 'backend.shepthon',
    content: lines.join('\n'),
    models: Array.from(models),
    endpoints
  };
}

/**
 * Generate model definitions from entities and routes
 */
function generateModelDefinitions(
  routes: APIRoute[],
  entities: Entity[]
): string[] {
  const lines: string[] = [];
  const generatedModels = new Set<string>();

  // First, use explicit entities from Prisma
  for (const entity of entities) {
    if (generatedModels.has(entity.name)) continue;
    generatedModels.add(entity.name);

    lines.push(`model ${entity.name} {`);
    for (const field of entity.fields) {
      const shepthonType = mapFieldType(field.type);
      const optional = field.required ? '' : '?';
      lines.push(`  ${field.name}${optional}: ${shepthonType}`);
    }
    lines.push('}');
    lines.push('');
  }

  // Then, infer models from route Prisma operations
  for (const route of routes) {
    if (route.prismaModel && !generatedModels.has(capitalize(route.prismaModel))) {
      const modelName = capitalize(route.prismaModel);
      generatedModels.add(modelName);

      lines.push(`model ${modelName} {`);
      lines.push('  id: String');
      
      // Add body fields as model fields
      for (const field of route.bodyFields) {
        lines.push(`  ${field}: String`);
      }
      
      lines.push('  createdAt: DateTime');
      lines.push('  updatedAt: DateTime');
      lines.push('}');
      lines.push('');
    }
  }

  return lines;
}

/**
 * Map ShepLang/Prisma field type to ShepThon type
 */
function mapFieldType(type: string): string {
  const typeMap: Record<string, string> = {
    'text': 'String',
    'string': 'String',
    'String': 'String',
    'number': 'Int',
    'int': 'Int',
    'Int': 'Int',
    'integer': 'Int',
    'float': 'Float',
    'Float': 'Float',
    'Decimal': 'Float',
    'boolean': 'Boolean',
    'Boolean': 'Boolean',
    'yes/no': 'Boolean',
    'date': 'DateTime',
    'Date': 'DateTime',
    'DateTime': 'DateTime',
    'object': 'Json',
    'Json': 'Json'
  };

  return typeMap[type] || 'String';
}

/**
 * Convert API route to ShepThon endpoint
 */
function routeToEndpoint(route: APIRoute): ShepThonEndpoint | null {
  const model = route.prismaModel 
    ? route.prismaModel.toLowerCase() + 's'  // Pluralize for table name
    : inferModelFromPath(route.path);

  if (!model) {
    return null;
  }

  const operation = mapPrismaToShepThon(route.method, route.prismaOperation);
  const hasParams = route.params.length > 0;
  const usesBody = ['POST', 'PUT', 'PATCH'].includes(route.method);

  return {
    method: route.method,
    path: route.path,
    operation,
    model,
    usesBody,
    usesParams: hasParams
  };
}

/**
 * Map HTTP method + Prisma operation to ShepThon db operation
 */
function mapPrismaToShepThon(
  method: HTTPMethod,
  prismaOp?: PrismaOperation
): ShepThonEndpoint['operation'] {
  // First try Prisma operation
  if (prismaOp) {
    const prismaMap: Partial<Record<PrismaOperation, ShepThonEndpoint['operation']>> = {
      'findMany': 'db.all',
      'findUnique': 'db.get',
      'findFirst': 'db.get',
      'create': 'db.add',
      'update': 'db.update',
      'delete': 'db.remove'
    };
    if (prismaMap[prismaOp]) {
      return prismaMap[prismaOp]!;
    }
  }

  // Fall back to HTTP method
  const methodMap: Record<HTTPMethod, ShepThonEndpoint['operation']> = {
    'GET': 'db.all',
    'POST': 'db.add',
    'PUT': 'db.update',
    'PATCH': 'db.update',
    'DELETE': 'db.remove',
    'HEAD': 'db.get',
    'OPTIONS': 'db.all'
  };

  return methodMap[method];
}

/**
 * Infer model/table name from API path
 */
function inferModelFromPath(path: string): string | null {
  // /api/tasks/:id -> tasks
  // /api/users -> users
  const segments = path.split('/').filter(Boolean);
  
  // Skip 'api' segment
  const apiIndex = segments.indexOf('api');
  if (apiIndex >= 0 && segments.length > apiIndex + 1) {
    const modelSegment = segments[apiIndex + 1];
    // Skip parameter segments
    if (!modelSegment.startsWith(':')) {
      return modelSegment;
    }
  }

  return null;
}

/**
 * Generate a single endpoint line
 */
function generateEndpointLine(
  endpoint: ShepThonEndpoint,
  route: APIRoute
): string {
  let line = `${endpoint.method} ${route.path} -> ${endpoint.operation}("${endpoint.model}"`;

  // Add params for single-item operations
  if (endpoint.usesParams && route.params.length > 0) {
    const paramName = route.params[0].name;
    if (endpoint.operation === 'db.get') {
      line += `, params.${paramName}`;
    } else if (endpoint.operation === 'db.update') {
      line += `, params.${paramName}, body`;
    } else if (endpoint.operation === 'db.remove') {
      line += `, params.${paramName}`;
    }
  } else if (endpoint.usesBody) {
    line += ', body';
  }

  line += ')';
  return line;
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate ShepLang action operations from correlated routes
 */
export function generateShepLangActions(
  routes: APIRoute[]
): { name: string; operations: string[] }[] {
  const actions: { name: string; operations: string[] }[] = [];

  for (const route of routes) {
    const actionName = inferActionName(route);
    const operations: string[] = [];

    // Generate call or load based on method
    if (route.method === 'GET') {
      const variable = inferModelFromPath(route.path) || 'data';
      operations.push(`load GET "${route.path}" into ${variable}`);
    } else {
      const fields = route.bodyFields.length > 0 
        ? ` with ${route.bodyFields.join(', ')}` 
        : '';
      operations.push(`call ${route.method} "${route.path}"${fields}`);
    }

    actions.push({ name: actionName, operations });
  }

  return actions;
}

/**
 * Infer action name from route
 */
function inferActionName(route: APIRoute): string {
  const model = route.prismaModel || inferModelFromPath(route.path) || 'Item';
  const capitalModel = capitalize(model.replace(/s$/, '')); // Singularize

  const methodNames: Record<HTTPMethod, string> = {
    'GET': route.params.length > 0 ? `Get${capitalModel}` : `Load${capitalModel}s`,
    'POST': `Create${capitalModel}`,
    'PUT': `Update${capitalModel}`,
    'PATCH': `Update${capitalModel}`,
    'DELETE': `Delete${capitalModel}`,
    'HEAD': `Check${capitalModel}`,
    'OPTIONS': `Options${capitalModel}`
  };

  return methodNames[route.method];
}
