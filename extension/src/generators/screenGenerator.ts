/**
 * Screen Generator for ShepLang
 * 
 * Generates .shep screen files from questionnaire data
 */

import { EntityDefinition, ProjectQuestionnaire } from '../wizard/types';

export class ScreenGenerator {
  /**
   * Generate dashboard screen
   */
  public generateDashboard(questionnaire: ProjectQuestionnaire): string {
    const hasRealtime = questionnaire.realtime;
    const entities = questionnaire.entities;
    
    return `# Dashboard Screen
# Generated by ShepLang Wizard for ${questionnaire.projectName}

view Dashboard:
  header: "Welcome to ${questionnaire.projectName}"
  subtitle: "Overview of your application"
  
  # Key Metrics Cards
  section metrics:
    card totalUsers:
      title: "Total Users"
      value: load GET "/metrics/users/count"
      icon: "ðŸ‘¥"
      
    card totalRevenue:
      title: "Total Revenue"
      value: load GET "/metrics/revenue/total"
      icon: "ðŸ’°"
      
    card activeProjects:
      title: "Active Projects"
      value: load GET "/metrics/projects/active"
      icon: "ðŸ“Š"
      
    card recentActivity:
      title: "Recent Activity"
      value: load GET "/metrics/activity/recent"
      icon: "ðŸ””"
  
  # Recent Items Section
  section recent:
    title: "Recent Activity"
    list recentItems:
      load GET "/activity/recent" into recentItems
      for item in recentItems:
        display item.title
        display item.timestamp
        button "View" -> viewItem(item.id)
  
  # Quick Actions
  section actions:
    title: "Quick Actions"
    button "New ${entities[0]?.name || 'Item'}" -> create${entities[0]?.name || 'Item'}
    button "View Reports" -> showReports
    button "Settings" -> showSettings
  
  # Real-time Updates (if enabled)
  ${hasRealtime ? `
  realtime:
    subscribe "dashboard-updates"
    onMessage: refreshMetrics
  ` : ''}
  
  # Actions
  action create${entities[0]?.name || 'Item'}():
    show Create${entities[0]?.name || 'Item'}Form
    
  action viewItem(id):
    load GET "/items/:id" into item
    show ItemDetail
    
  action showReports():
    show ReportsScreen
    
  action showSettings():
    show SettingsScreen
    
  action refreshMetrics():
    load GET "/metrics/refresh" into metrics
    update metrics cards
`;
  }

  /**
   * Generate entity list screen
   */
  public generateEntityList(entity: EntityDefinition, questionnaire: ProjectQuestionnaire): string {
    const entityName = entity.name;
    const entityNameLower = entityName.toLowerCase();
    
    return `# ${entityName} List Screen
# Generated by ShepLang Wizard for ${questionnaire.projectName}

view ${entityName}List:
  header: "${entityName}s"
  subtitle: "Manage your ${entityNameLower}s"
  
  # Search and Filter
  section search:
    input searchQuery:
      placeholder: "Search ${entityNameLower}s..."
      onChange: filter${entityName}s
      
    select filterStatus:
      options: ["All", "Active", "Inactive", "Pending"]
      onChange: filter${entityName}s
  
  # ${entityName} List
  section list:
    list ${entityNameLower}s:
      load GET "/${entityNameLower}" with searchQuery, filterStatus into ${entityNameLower}s
      for ${entityNameLower} in ${entityNameLower}s:
        card ${entityNameLower}Card:
          title: ${entityNameLower}.${this.getDisplayField(entity)}
          subtitle: ${this.generateSubtitleFields(entity)}
          status: ${entityNameLower}.status
          actions:
            button "View" -> view${entityName}(${entityNameLower}.id)
            button "Edit" -> edit${entityName}(${entityNameLower}.id)
            button "Delete" -> delete${entityName}(${entityNameLower}.id)
  
  # Pagination
  section pagination:
    if hasMore${entityName}s:
      button "Load More" -> loadMore${entityName}s
  
  # Floating Action Button
  fab:
    button "+" -> create${entityName}()
  
  # Actions
  action filter${entityName}s():
    load GET "/${entityNameLower}" with searchQuery, filterStatus into ${entityNameLower}s
    refresh list
    
  action view${entityName}(id):
    load GET "/${entityNameLower}/:id" into ${entityNameLower}
    show ${entityName}Detail
    
  action edit${entityName}(id):
    load GET "/${entityNameLower}/:id" into ${entityNameLower}
    show Edit${entityName}Form
    
  action delete${entityName}(id):
    show DeleteConfirmation
    onConfirm: confirmDelete${entityName}(id)
    
  action confirmDelete${entityName}(id):
    call DELETE "/${entityNameLower}/:id"
    load GET "/${entityNameLower}" into ${entityNameLower}s
    refresh list
    
  action create${entityName}():
    show Create${entityName}Form
    
  action loadMore${entityName}s():
    load GET "/${entityNameLower}/more" with page into more${entityNameLower}s
    append to ${entityNameLower}s
`;
  }

  /**
   * Generate entity detail screen
   */
  public generateEntityDetail(entity: EntityDefinition, questionnaire: ProjectQuestionnaire): string {
    const entityName = entity.name;
    const entityNameLower = entityName.toLowerCase();
    
    return `# ${entityName} Detail Screen
# Generated by ShepLang Wizard for ${questionnaire.projectName}

view ${entityName}Detail:
  header: "${entityName} Details"
  subtitle: "{{${entityNameLower}.${this.getDisplayField(entity)}}}"
  
  # Breadcrumb
  breadcrumb:
    link "Home" -> Dashboard
    link "${entityName}s" -> ${entityName}List
    link "Details" -> current
  
  # Actions Bar
  section actions:
    button "Edit" -> edit${entityName}(${entityNameLower}.id)
    button "Delete" -> delete${entityName}(${entityNameLower}.id)
    button "Share" -> share${entityName}(${entityNameLower}.id)
  
  # Main Content
  section details:
    ${this.generateDetailFields(entity)}
  
  # Related Items
  ${this.generateRelatedSection(entity, questionnaire)}
  
  # Activity Log
  section activity:
    title: "Activity History"
    list activities:
      load GET "/${entityNameLower}/:id/activity" into activities
      for activity in activities:
        display activity.action
        display activity.timestamp
        display activity.user
  
  # Comments/Notes (if applicable)
  ${this.shouldHaveComments(entity) ? `
  section comments:
    title: "Comments"
    list comments:
      load GET "/${entityNameLower}/:id/comments" into comments
      for comment in comments:
        display comment.content
        display comment.author
        display comment.timestamp
    
    form addComment:
      input commentText:
        placeholder: "Add a comment..."
      button "Post" -> postComment(${entityNameLower}.id, commentText)
  ` : ''}
  
  # Actions
  action edit${entityName}(id):
    load GET "/${entityNameLower}/:id" into ${entityNameLower}
    show Edit${entityName}Form
    
  action delete${entityName}(id):
    show DeleteConfirmation
    onConfirm: confirmDelete${entityName}(id)
    
  action confirmDelete${entityName}(id):
    call DELETE "/${entityNameLower}/:id"
    show ${entityName}List
    
  action share${entityName}(id):
    show ShareDialog with ${entityNameLower}
    
  action postComment(id, text):
    call POST "/${entityNameLower}/:id/comments" with text
    load GET "/${entityNameLower}/:id/comments" into comments
    refresh comments
`;
  }

  /**
   * Generate create/edit form screen
   */
  public generateFormScreen(entity: EntityDefinition, questionnaire: ProjectQuestionnaire): string {
    const entityName = entity.name;
    const entityNameLower = entityName.toLowerCase();
    
    return `# ${entityName} Form Screen
# Generated by ShepLang Wizard for ${questionnaire.projectName}

view Create${entityName}Form:
  header: "Create ${entityName}"
  subtitle: "Add a new ${entityNameLower} to your system"
  
  form ${entityNameLower}Form:
    ${this.generateFormFields(entity)}
    
    section actions:
      button "Save" -> save${entityName}()
      button "Cancel" -> cancel()
  
  # Actions
  action save${entityName}():
    validate ${entityNameLower}Form
    if valid:
      call POST "/${entityNameLower}" with formData
      show ${entityName}List
    else:
      show validationErrors
      
  action cancel():
    show ${entityName}List

view Edit${entityName}Form:
  header: "Edit ${entityName}"
  subtitle: "Update ${entityNameLower} information"
  
  form ${entityNameLower}Form:
    load GET "/${entityNameLower}/:id" into ${entityNameLower}
    ${this.generateFormFields(entity, true)}
    
    section actions:
      button "Update" -> update${entityName}()
      button "Cancel" -> cancel()
  
  # Actions
  action update${entityName}():
    validate ${entityNameLower}Form
    if valid:
      call PUT "/${entityNameLower}/:id" with ${entityNameLower}.id, formData
      show ${entityName}List
    else:
      show validationErrors
      
  action cancel():
    show ${entityName}List
`;
  }

  /**
   * Helper methods
   */
  private getDisplayField(entity: EntityDefinition): string {
    // Prefer name, title, or first text field
    const nameField = entity.fields.find(f => 
      f.name.toLowerCase() === 'name' || 
      f.name.toLowerCase() === 'title'
    );
    
    if (nameField) return nameField.name;
    
    const firstTextField = entity.fields.find(f => f.type === 'text');
    return firstTextField?.name || 'id';
  }

  private generateSubtitleFields(entity: EntityDefinition): string {
    const subtitleFields: string[] = [];
    
    // Add common subtitle fields
    if (entity.fields.some(f => f.name.toLowerCase() === 'email')) {
      subtitleFields.push(`${entity.name.toLowerCase()}.email`);
    }
    
    if (entity.fields.some(f => f.name.toLowerCase() === 'status')) {
      subtitleFields.push(`${entity.name.toLowerCase()}.status`);
    }
    
    if (entity.fields.some(f => f.type === 'date' && f.name.toLowerCase().includes('created'))) {
      subtitleFields.push(`formatDate(${entity.name.toLowerCase()}.createdAt)`);
    }
    
    return subtitleFields.join(' + " â€¢ " + ');
  }

  private generateDetailFields(entity: EntityDefinition): string {
    return entity.fields.map(field => {
      const fieldName = field.name;
      const fieldLabel = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
      
      switch (field.type) {
        case 'text':
          return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: ${entity.name.toLowerCase()}.${fieldName}`;
          
        case 'number':
          if (fieldName.toLowerCase().includes('price')) {
            return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: formatCurrency(${entity.name.toLowerCase()}.${fieldName})`;
          } else {
            return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: ${entity.name.toLowerCase()}.${fieldName}`;
          }
          
        case 'date':
          return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: formatDate(${entity.name.toLowerCase()}.${fieldName})`;
          
        case 'yes/no':
          return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: ${entity.name.toLowerCase()}.${fieldName} ? "Yes" : "No"`;
          
        case 'image':
          return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: image ${entity.name.toLowerCase()}.${fieldName}`;
          
        default:
          return `    field ${fieldName}:
          label: "${fieldLabel}"
          value: ${entity.name.toLowerCase()}.${fieldName}`;
      }
    }).join('\n');
  }

  private generateRelatedSection(entity: EntityDefinition, questionnaire: ProjectQuestionnaire): string {
    // Generate related items based on entity relationships
    const entityName = entity.name.toLowerCase();
    
    if (entityName === 'user') {
      return `
  section related:
    title: "User's Teams"
    list teams:
      load GET "/users/:id/teams" into teams
      for team in teams:
        display team.name
        button "View" -> viewTeam(team.id)
`;
    }
    
    if (entityName === 'order') {
      return `
  section related:
    title: "Order Items"
    list items:
      load GET "/orders/:id/items" into items
      for item in items:
        display item.productName
        display item.quantity
        display item.price
`;
    }
    
    return '';
  }

  private shouldHaveComments(entity: EntityDefinition): boolean {
    const entityName = entity.name.toLowerCase();
    return ['user', 'order', 'project', 'task', 'post', 'article'].includes(entityName);
  }

  private generateFormFields(entity: EntityDefinition, isEdit: boolean = false): string {
    return entity.fields.map(field => {
      const fieldName = field.name;
      const fieldLabel = fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
      const required = field.required ? ' required' : '';
      const defaultValue = isEdit ? ` value: "${entity.name.toLowerCase()}.${fieldName}"` : '';
      
      switch (field.type) {
        case 'text':
          if (fieldName.toLowerCase() === 'email') {
            return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "email"${required}${defaultValue}`;
          } else if (fieldName.toLowerCase().includes('description')) {
            return `    textarea ${fieldName}:
          label: "${fieldLabel}"
          rows: 4${required}${defaultValue}`;
          } else {
            return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "text"${required}${defaultValue}`;
          }
          
        case 'number':
          if (fieldName.toLowerCase().includes('price')) {
            return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "number"
          step: "0.01"${required}${defaultValue}`;
          } else {
            return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "number"${required}${defaultValue}`;
          }
          
        case 'date':
          return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "date"${required}${defaultValue}`;
          
        case 'yes/no':
          return `    checkbox ${fieldName}:
          label: "${fieldLabel}"${defaultValue}`;
          
        case 'image':
          return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "file"
          accept: "image/*"${required}`;
          
        default:
          return `    input ${fieldName}:
          label: "${fieldLabel}"
          type: "text"${required}${defaultValue}`;
      }
    }).join('\n');
  }
}
