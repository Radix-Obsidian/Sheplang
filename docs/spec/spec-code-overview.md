# Spec-Code in the ShepLang Ecosystem

## What is Spec-Code?

**Spec-code** is a structured, language-agnostic representation of an application that captures:
- **Data entities** (models, fields, types)
- **Screens/views** (UI layouts, widgets, navigation)
- **Actions** (user interactions, business logic)

It serves as an intermediate format between design tools (like Figma) and the ShepLang programming language.

## Why Spec-Code?

### 1. AI-Friendliness
Spec-code is designed to be easily consumed and generated by AI systems:
- Structured JSON format
- Clear, unambiguous schema
- No syntactic ambiguity
- Perfect for LLM input/output

### 2. Repeatability
The same spec-code always produces the same ShepLang output:
- Deterministic conversion
- Version-controllable
- Auditable transformations

### 3. Verification
Spec-code enables compile-time verification of the entire stack:
- Schema validation ensures correctness before conversion
- Generated ShepLang code runs through ShepVerify
- End-to-end verification from design to deployment

### 4. Clear Contracts
Spec-code creates explicit contracts between:
- Design tools ↔ Development tools
- Frontend ↔ Backend
- Human designers ↔ AI code generators

## How Spec-Code Maps to ShepLang

Spec-code structures map directly to ShepLang constructs:

| Spec-Code Element | ShepLang Construct | Example |
|------------------|-------------------|---------|
| `FigmaShepEntity` | `data` block | `data Task: fields: ...` |
| `FigmaShepScreen` | `view` block | `view TaskList: list Task ...` |
| Button with action | `button` → `action` | `button "Save" -> SaveTask` |
| Entity fields | `fields:` declaration | `title: text`, `done: yes/no` |

### Example Mapping

**Spec-Code (JSON):**
```json
{
  "appName": "TodoApp",
  "entities": [
    {
      "name": "Task",
      "fields": [
        { "name": "title", "type": "text", "required": true }
      ]
    }
  ],
  "screens": [
    {
      "name": "TaskList",
      "type": "list",
      "entity": "Task",
      "widgets": [
        { "kind": "list", "entityName": "Task" }
      ]
    }
  ]
}
```

**Generated ShepLang:**
```shep
app TodoApp

data Task:
  fields:
    title: text

view TaskList:
  list Task
```

## Spec-Code Formats

Currently implemented:
- **FigmaShepSpec** - Design-to-code from Figma

Planned formats:
- **AIVDSpec** - AI-generated specifications
- **CompanionSpec** - Shep Companion conversational specs
- **AnalyticsSpec** - Data-driven app generation

## Tools That Consume Spec-Code

### Current
1. **Figma → Shep Bridge** (`@goldensheepai/figma-shep-import`)
   - Converts FigmaShepSpec → .shep files
   - Location: `sheplang/packages/figma-shep-import/`
   - [View package](../sheplang/packages/figma-shep-import/)

### Future
2. **AIVD (AI Visual Designer)**
   - AI generates spec-code from natural language
   - Spec-code → ShepLang → deployment

3. **Shep Companion**
   - Conversational interface for building apps
   - Builds spec-code iteratively through dialogue

4. **Analytics Tools**
   - Generate apps from data schemas
   - Convert existing databases to ShepLang

## References

- **FigmaShepSpec Schema**: [sheplang/packages/figma-shep-import/src/spec/schema.json](../sheplang/packages/figma-shep-import/src/spec/schema.json)
- **TypeScript Types**: [sheplang/packages/figma-shep-import/src/spec/types.ts](../sheplang/packages/figma-shep-import/src/spec/types.ts)
- **Figma Integration Flow**: [figma-to-shep-flow.md](./figma-to-shep-flow.md)
- **Spec Format Details**: [figma-to-shep-spec.md](./figma-to-shep-spec.md)

## Benefits for the ShepLang Ecosystem

### For Developers
- Import designs directly from Figma
- No manual translation of mockups
- Guaranteed consistency between design and code

### For Designers
- Designs become functioning prototypes instantly
- No "lost in translation" issues
- Direct feedback loop

### For AI Systems
- Structured input/output format
- No need to understand ShepLang syntax
- Focus on logic, not syntax

### For the Platform
- Unified format across all tools
- Extensible to new input sources
- Central point for verification and optimization

## The Spec-Code Journey

```
[Design Tool] → Spec-Code → [ShepLang] → [BobaScript] → [TypeScript] → [Running App]
                    ↓
              [Validation]
                    ↓
              [Verification]
```

Every step is validated:
1. **Spec-Code Validation** - JSON schema check
2. **ShepLang Verification** - ShepVerify 4-phase check
3. **Runtime Verification** - Type safety at every layer

## Extending Spec-Code

To add a new spec-code format:

1. Define TypeScript types in `packages/your-tool-import/src/spec/types.ts`
2. Create JSON Schema in `packages/your-tool-import/src/spec/schema.json`
3. Implement converter in `packages/your-tool-import/src/bridge/converter.ts`
4. Add CLI commands for validation and import
5. Document the format in `docs/spec/your-format-spec.md`
6. Add examples in `packages/your-tool-import/src/spec/examples/`

## Philosophy

Spec-code embodies the ShepLang philosophy:

> **"AI writes the specification, the system proves it correct, and the founder launches without fear."**

By making specifications:
- Machine-readable (JSON)
- Machine-verifiable (schema + ShepVerify)
- Machine-executable (ShepLang compiler)

We enable a new paradigm where:
- Designs become apps automatically
- AI can safely generate production code
- Non-technical founders can build real products
- Verification is built-in, not bolted-on

---

**Part of the ShepLang AIVP (AI-Verified Programming) ecosystem.**
